# Elephant Feg protocol exploit demo

This is a demo to replay the FegToken exploit happened on May-15-2022

https://bscscan.com/tx/0x77cf448ceaf8f66e06d1537ef83218725670d3a509583ea0d161533fda56c063

## Installation & Run


```bash
npm install
npx hardhat run scripts/execute.js
```

## Explanation
Trace the transacition with blocksecteam - https://versatile.blocksecteam.com/tx/bsc/0x77cf448ceaf8f66e06d1537ef83218725670d3a509583ea0d161533fda56c063

The following steps were executed 

1. flash loan 915 WBNB from DVM
2. withdraw 116 BNB from WBNB and mint 116 fBNB
3. create multiple malicious contracts
4. deposit 115 fBNB into FEGexPro calling `depositInternal`
5. calling FEGexPro `swapToSwap`
6. repeat steps 4-5 multiple time with the malicious contract created on step 3.
7. The malicious contract call `fbnb.transferFronm` and `Feg.transferFrom` to drain the FEGexPro
8. Finally user return flashLoan and take profit


There are several reasons that make this exploit possible.
1. `swapToSwap` function doesn't validate the function parameter `path` and making it possible for malicious contract to execute arbitirary code.  the following code allow malicious contract(`path`) to transfer fund out of the pool within the approval amounts
```
    IERC20(address(Main)).approve(address(path), amt);   
    _totalSupply2 -= amt;
    _balances2[msg.sender] -= amt;
    swap(path).depositInternal(Main, amt);
    (uint256 tokens, uint256 mains) = FEgexPair(path).userBalanceInternal(address(this));
    swap(path).payMain(to, mains);
```

2. The inconsistent balanace between the approval amount and the acutal balance changing. Everytime after `depositInternal` function is called, user balance (`_balance2[msg.sender]`) will updated despite the fact that it is deducted from the malicious swap when calling `swapToSwap`.
```
    uint256 bef = _records[Main].balance;
    _pullUnderlying(Main, msg.sender, amt);
    uint256 aft = bsub(IERC20(Main).balanceOf(address(this)), badd(_totalSupply2, badd(_totalSupply7, _totalSupply8)));
    uint256 finalAmount = bsub(aft, bef);
    _totalSupply2 = badd(_totalSupply2, finalAmount);
    _balances2[msg.sender] = badd(_balances2[msg.sender], finalAmount);
```

## Disclaimer
This codebase is for demonstration purposes only

## License
[MIT](https://choosealicense.com/licenses/mit/)